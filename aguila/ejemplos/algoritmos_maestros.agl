#  20 ALGORITMOS MAESTROS EN GUILA v2.3.0
# Demostraci贸n de potencia, sintaxis y velocidad.

# ==========================================
# 1. Longest Increasing Subsequence (LIS)
# ==========================================
funcion lis(nums) {
    si nums.longitud() == 0 { retornar 0 }
    dp = []
    para i = 0 hasta nums.longitud() { dp.agregar(1) }
    
    max_len = 1
    para i = 1 hasta nums.longitud() {
        para j = 0 hasta i {
            # imprimir a"Comparando {nums[i]} > {nums[j]}"
            si nums[i] > nums[j] {
                si dp[j] + 1 > dp[i] {
                    dp[i] = dp[j] + 1
                }
            }
        }
        si dp[i] > max_len { max_len = dp[i] }
    }
    retornar max_len
}

# ==========================================
# 2. Edit Distance (Levenshtein)
# ==========================================
funcion distancia_edicion(palabra1, palabra2) {
    # Convertir a listas para acceso por 铆ndice (workaround temporal)
    p1 = palabra1.dividir("")
    p2 = palabra2.dividir("")
    
    m = p1.longitud()
    n = p2.longitud()
    dp = [] # Matriz (m+1) x (n+1)
    
    # Inicializar matriz
    para i = 0 hasta m + 1 {
        fila = []
        para j = 0 hasta n + 1 { fila.agregar(0) }
        dp.agregar(fila)
    }
    
    para i = 0 hasta m + 1 { dp[i][0] = i }
    para j = 0 hasta n + 1 { dp[0][j] = j }
    
    para i = 1 hasta m + 1 {
        para j = 1 hasta n + 1 {
            costo = 1
            si p1[i-1] == p2[j-1] { costo = 0 }
            
            # Minimo de: inserci贸n, eliminaci贸n, sustituci贸n
            min_val = dp[i-1][j] + 1
            si dp[i][j-1] + 1 < min_val { min_val = dp[i][j-1] + 1 }
            si dp[i-1][j-1] + costo < min_val { min_val = dp[i-1][j-1] + costo }
            
            dp[i][j] = min_val
        }
    }
    retornar dp[m][n]
}

# ==========================================
# 6. Number of Islands (DFS)
# ==========================================
funcion num_islas(grid) {
    si grid.longitud() == 0 { retornar 0 }
    filas = grid.longitud()
    cols = grid[0].longitud()
    count = 0
    
    para i = 0 hasta filas {
        para j = 0 hasta cols {
            si grid[i][j] == "1" {
                count = count + 1
                dfs_islas(grid, i, j, filas, cols)
            }
        }
    }
    retornar count
}

funcion dfs_islas(grid, i, j, filas, cols) {
    si i < 0 o j < 0 o i >= filas o j >= cols o grid[i][j] == "0" {
        retornar
    }
    grid[i][j] = "0" # Marcar como visitado
    dfs_islas(grid, i+1, j, filas, cols)
    dfs_islas(grid, i-1, j, filas, cols)
    dfs_islas(grid, i, j+1, filas, cols)
    dfs_islas(grid, i, j-1, filas, cols)
}

# ==========================================
# 9. Trapping Rain Water
# ==========================================
funcion atrapar_agua(alturas) {
    n = alturas.longitud()
    si n == 0 { retornar 0 }
    
    izq = 0
    der = n - 1
    max_izq = 0
    max_der = 0
    agua = 0
    
    mientras izq <= der {
        si alturas[izq] <= alturas[der] {
            si alturas[izq] >= max_izq {
                max_izq = alturas[izq]
            } sino {
                agua = agua + (max_izq - alturas[izq])
            }
            izq = izq + 1
        } sino {
            si alturas[der] >= max_der {
                max_der = alturas[der]
            } sino {
                agua = agua + (max_der - alturas[der])
            }
            der = der - 1
        }
    }
    retornar agua
}

# ==========================================
# 11. N-Queens
# ==========================================
funcion n_reinas(n) {
    tablero = []
    para i = 0 hasta n { tablero.agregar(-1) }
    res = []
    resolver_n_reinas(0, tablero, res, n)
    retornar res.longitud()
}

funcion resolver_n_reinas(fila, tablero, res, n) {
    si fila == n {
        res.agregar(1)
        retornar
    }
    para col = 0 hasta n {
        es_valido = verdadero
        para f = 0 hasta fila {
            si tablero[f] == col { 
                es_valido = falso
                romper 
            }
            diff = fila - f
            si tablero[f] == col - diff { 
                es_valido = falso
                romper 
            }
            si tablero[f] == col + diff { 
                es_valido = falso
                romper 
            }
        }
        
        si es_valido {
            tablero[fila] = col
            resolver_n_reinas(fila + 1, tablero, res, n)
        }
    }
}

# ==========================================
# 12. Sudoku Solver
# ==========================================
funcion resolver_sudoku(tablero) {
    para i = 0 hasta 9 {
        para j = 0 hasta 9 {
            si tablero[i][j] == 0 {
                para num = 1 hasta 10 {
                    si es_valido_sudoku(tablero, i, j, num) {
                        tablero[i][j] = num
                        si resolver_sudoku(tablero) { retornar verdadero }
                        tablero[i][j] = 0
                    }
                }
                retornar falso
            }
        }
    }
    retornar verdadero
}

funcion es_valido_sudoku(tablero, fila, col, num) {
    para x = 0 hasta 9 {
        si tablero[fila][x] == num { retornar falso }
        si tablero[x][col] == num { retornar falso }
        
        # Bloque 3x3
        bloque_fila = 3 * (fila / 3).piso() + (x / 3).piso()
        bloque_col = 3 * (col / 3).piso() + (x % 3)
        si tablero[bloque_fila][bloque_col] == num { retornar falso }
    }
    retornar verdadero
}

# ==========================================
# 19. Gas Station
# ==========================================
funcion circuito_gasolinera(gas, costo) {
    total_gas = 0
    total_costo = 0
    tanque = 0
    inicio = 0
    
    para i = 0 hasta gas.longitud() {
        total_gas = total_gas + gas[i]
        total_costo = total_costo + costo[i]
        tanque = tanque + gas[i] - costo[i]
        si tanque < 0 {
            inicio = i + 1
            tanque = 0
        }
    }
    
    si total_gas < total_costo { retornar -1 }
    retornar inicio
}

# ==========================================
# PRUEBAS
# ==========================================
imprimir "--- 1. LIS ---"
nums = [10, 9, 2, 5, 3, 7, 101, 18]
imprimir a"LIS de {nums}: {lis(nums)}"

imprimir "\n--- 2. Edit Distance ---"
p1 = "horse"
p2 = "ros"
imprimir a"Distancia entre '{p1}' y '{p2}': {distancia_edicion(p1, p2)}"

#  [5,3,0,0,7,0,0,0,0],
#  [6,0,0,1,9,5,0,0,0],
imprimir "\n--- 6. Number of Islands ---"
grid = [
  ["1","1","1","1","0"],
  ["1","1","0","1","0"],
  ["1","1","0","0","0"],
  ["0","0","0","0","0"]
]
imprimir a"Islas: {num_islas(grid)}"

imprimir "\n--- 9. Trapping Rain Water ---"
alturas = [0,1,0,2,1,0,1,3,2,1,2,1]
imprimir a"Agua atrapada: {atrapar_agua(alturas)}"

imprimir "\n--- 11. N-Queens (8) ---"
imprimir a"Soluciones para 8 reinas: {n_reinas(8)}"

imprimir "\n--- 12. Sudoku Solver ---"
sudoku = [
 [5,3,0,0,7,0,0,0,0],
 [6,0,0,1,9,5,0,0,0],
 [0,9,8,0,0,0,0,6,0],
 [8,0,0,0,6,0,0,0,3],
 [4,0,0,8,0,3,0,0,1],
 [7,0,0,0,2,0,0,0,6],
 [0,6,0,0,0,0,2,8,0],
 [0,0,0,4,1,9,0,0,5],
 [0,0,0,0,8,0,0,7,9]
]
resolver_sudoku(sudoku)
imprimir "Sudoku resuelto (primera fila):"
imprimir sudoku[0]

imprimir "\n--- 19. Gas Station ---"
gas = [1,2,3,4,5]
costo = [3,4,5,1,2]
imprimir a"Inicio circuito: {circuito_gasolinera(gas, costo)}"
