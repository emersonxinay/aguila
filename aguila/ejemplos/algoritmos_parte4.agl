# ü¶Ö ALGORITMOS MAESTROS - PARTE 4
# Backtracking y √Årboles Avanzados

# ==========================================
# 46. Permutations
# ==========================================
funcion permutaciones(nums) {
    res = []
    backtrack_perm(res, [], nums)
    retornar res
}

funcion backtrack_perm(res, actual, nums) {
    si actual.longitud() == nums.longitud() {
        # Clonar lista actual
        copia = []
        para x en actual { copia.agregar(x) }
        res.agregar(copia)
        retornar nulo
    }
    
    para n en nums {
        # Verificar si n ya est√° en actual (b√∫squeda lineal simple)
        encontrado = falso
        para x en actual {
            si x == n { encontrado = verdadero }
        }
        
        si !encontrado {
            actual.agregar(n)
            backtrack_perm(res, actual, nums)
            actual.eliminar(actual.longitud() - 1) # Backtrack: eliminar √∫ltimo
        }
    }
}

# ==========================================
# 22. Generate Parentheses
# ==========================================
funcion generar_parentesis(n) {
    res = []
    backtrack_par(res, "", 0, 0, n)
    retornar res
}

funcion backtrack_par(res, actual, abrir, cerrar, max_n) {
    si actual.longitud() == max_n * 2 {
        res.agregar(actual)
        retornar nulo
    }
    
    si abrir < max_n {
        backtrack_par(res, actual + "(", abrir + 1, cerrar, max_n)
    }
    
    si cerrar < abrir {
        backtrack_par(res, actual + ")", abrir, cerrar + 1, max_n)
    }
}

# ==========================================
# 297. Serialize and Deserialize Binary Tree
# ==========================================
clase NodoArbol {
    val = 0
    izq = nulo
    der = nulo
    
    nuevo(v) {
        yo.val = v
    }
}

clase Codec {
    nuevo() {}
    
    serializar(raiz) {
        si raiz == nulo { retornar "N" }
        retornar raiz.val.a_texto() + "," + yo.serializar(raiz.izq) + "," + yo.serializar(raiz.der)
    }
    
    deserializar(data) {
        valores = data.dividir(",")
        # Usamos una lista mutable para consumir valores como una cola
        # Pero como no tenemos 'shift' eficiente o puntero global f√°cil, pasamos un contenedor de √≠ndice
        ctx = {"idx": 0}
        retornar yo._deserializar_rec(valores, ctx)
    }
    
    _deserializar_rec(valores, ctx) {
        idx = ctx["idx"]
        si idx >= valores.longitud() { retornar nulo }
        
        val_str = valores[idx]
        ctx["idx"] = idx + 1
        
        si val_str == "N" {
            retornar nulo
        }
        
        nodo = NodoArbol(val_str.a_numero())
        nodo.izq = yo._deserializar_rec(valores, ctx)
        nodo.der = yo._deserializar_rec(valores, ctx)
        retornar nodo
    }
}

# ==========================================
# 208. Implement Trie (Prefix Tree)
# ==========================================
clase NodoTrie {
    hijos = {}
    es_fin = falso
    
    nuevo() {
        yo.hijos = {}
        yo.es_fin = falso
    }
}

clase Trie {
    raiz = nulo
    
    nuevo() {
        yo.raiz = NodoTrie()
    }
    
    insertar(palabra) {
        nodo = yo.raiz
        n = palabra.longitud()
        para i = 0 hasta n {
            char = palabra.caracter_en(i)
            si !nodo.hijos.contiene(char) {
                nodo.hijos[char] = NodoTrie()
            }
            nodo = nodo.hijos[char]
        }
        nodo.es_fin = verdadero
    }
    
    buscar(palabra) {
        nodo = yo.raiz
        n = palabra.longitud()
        para i = 0 hasta n {
            char = palabra.caracter_en(i)
            si !nodo.hijos.contiene(char) {
                retornar falso
            }
            nodo = nodo.hijos[char]
        }
        retornar nodo.es_fin
    }
    
    inicia_con(prefijo) {
        nodo = yo.raiz
        n = prefijo.longitud()
        para i = 0 hasta n {
            char = prefijo.caracter_en(i)
            si !nodo.hijos.contiene(char) {
                retornar falso
            }
            nodo = nodo.hijos[char]
        }
        retornar verdadero
    }
}

# ==========================================
# PRUEBAS PARTE 4
# ==========================================

imprimir "--- 46. Permutations ---"
nums = [1, 2, 3]
imprimir a"Nums: {nums}"
perms = permutaciones(nums)
imprimir a"Permutaciones ({perms.longitud()}):"
para p en perms { imprimir p }

imprimir "\n--- 22. Generate Parentheses ---"
n = 3
imprimir a"n: {n}"
pars = generar_parentesis(n)
imprimir a"Par√©ntesis ({pars.longitud()}): {pars}"

imprimir "\n--- 297. Serialize/Deserialize Tree ---"
# Crear √°rbol: 1 -> (2, 3 -> (4, 5))
raiz = NodoArbol(1)
raiz.izq = NodoArbol(2)
raiz.der = NodoArbol(3)
raiz.der.izq = NodoArbol(4)
raiz.der.der = NodoArbol(5)

codec = Codec()
serializado = codec.serializar(raiz)
imprimir a"Serializado: {serializado}"

deserializado = codec.deserializar(serializado)
reserializado = codec.serializar(deserializado)
imprimir a"Reserializado: {reserializado}"
imprimir a"¬øCorrecto? {serializado == reserializado}"

imprimir "\n--- 208. Trie ---"
trie = Trie()
trie.insertar("apple")
imprimir a"Insertar 'apple'"
imprimir a"Buscar 'apple': {trie.buscar('apple')}"
imprimir a"Buscar 'app': {trie.buscar('app')}"
imprimir a"Inicia con 'app': {trie.inicia_con('app')}"
trie.insertar("app")
imprimir a"Insertar 'app'"
imprimir a"Buscar 'app': {trie.buscar('app')}"
